{{>licenseInfo}}
package {{apiPackage}}

{{#imports}}import _root_.{{import}}
{{/imports}}

import {{{modelPackage}}}.*

import cats.syntax.functor.*

object {{classFilename}}Client:
{{#operations}}
    {{#operation}}
        type {{{operationIdCamelCase}}}Response = {{{vendorExtensions.responseTypes}}}
    {{/operation}}
{{/operations}}
end {{classFilename}}Client

import {{classFilename}}Client.*

trait {{classFilename}}Client[F[_] : cats.Functor](transport : HttpRequest[Binary] => F[ResponseData]) {
{{#operations}}
    {{#operation}}

        def {{operationId}}AsRequest({{#allParams}}{{paramName}} : {{dataType}}{{#hasMore}},{{/hasMore}}{{/allParams}}) : HttpRequest.{{{vendorExtensions.HttpRequestInstance}}}[Binary] = {
            {{#hasBodyParam}}
                val {{operationId}}PayloadBytes = {{operationId}}AsBinary(ContentType.`{{{vendorExtensions.defaultContentType}}}`)({{bodyParam.paramName}})
            {{/hasBodyParam}}
            HttpRequest.{{{vendorExtensions.HttpRequestInstance}}}(RequestData(
            path = s"{{vendorExtensions.path-template}}",
            headers = HttpData({{#headerParams}}"{{paramName}}" -> {{paramName}}{{#hasMore}}, {{/hasMore}}{{/headerParams}}),
            cookies = HttpData({{#cookieParams}}"{{paramName}}" -> {{paramName}}{{#hasMore}}, {{/hasMore}}{{/cookieParams}}),
            formData = HttpData({{#formParams}}"{{paramName}}" -> {{paramName}}{{#hasMore}}, {{/hasMore}}{{/formParams}}),
            queryParams = HttpData({{#queryParams}}"{{paramName}}" -> {{paramName}}{{#hasMore}}, {{/hasMore}}{{/queryParams}}),
            body = {{#hasBodyParam}}Option({{operationId}}PayloadBytes){{else}}None{{/hasBodyParam}}
            ))
        }

        {{#vendorExtensions.hasReturnType}}
        /**
         * This maps a means to unmarshal the response by ResponseCoords (e.g. status code and content type),
         * which can be supplied/overridden in subclasses
         */
        def {{{operationId}}}AsResponse : Unmarshal[{{{operationIdCamelCase}}}Response] = {{>clientResponseMap}}
        {{/vendorExtensions.hasReturnType}}

        {{#hasBodyParam}}
        def {{{operationId}}}AsBinary : Marshal[{{{bodyParam.dataType}}}] = (_ : ContentType) match {
            case ContentType.`application/json` =>
              val writer = implicitly[Write[{{bodyParam.dataType}}, Array[Byte]]]
              ({{bodyParam.paramName}}:{{bodyParam.dataType}}) => writer.write({{bodyParam.paramName}})
            case ContentType.`application/octet-stream` =>
                val writer = implicitly[Write[{{bodyParam.dataType}}, Array[Byte]]]
                ({{bodyParam.paramName}}:{{bodyParam.dataType}}) => writer.write({{bodyParam.paramName}})
            case other => sys.error(s"BUG / TODO: content type '$other' not supported")
        }

        {{/hasBodyParam}}

        /** {{summary}}
        * {{description}}
        * parameters:
        {{#allParams}}
        * @{{paramName}} : {{dataType}} - {{hasMore}}
        {{/allParams}}
        * @return {{returnType}}
        */
        def {{operationId}}({{#allParams}}{{paramName}} : {{dataType}}{{#hasMore}},{{/hasMore}}{{/allParams}}) = {
            val request = {{operationId}}AsRequest({{#allParams}}{{paramName}}{{#hasMore}},{{/hasMore}}{{/allParams}})
           {{#vendorExtensions.hasReturnType}}
               transport(request).map({{operationId}}AsResponse)
           {{else}}
               transport(request)
           {{/vendorExtensions.hasReturnType}}
        }
    {{/operation}}
{{/operations}}
}



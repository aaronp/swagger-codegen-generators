{{>licenseInfo}}
package {{apiPackage}}

import scala.util.Try
import scala.annotation.targetName

opaque type ContentType = String

object ContentType:
  def apply(contentType : String) : ContentType = contentType.trim().toLowerCase()
  @targetName("application_json")
  val `application/json` :  ContentType = "application/json"
  @targetName("application_xml")
  val `application/xml` :  ContentType = "application/xml"
  @targetName("application_octetstream")
  val `application/octet-stream` :  ContentType = "application/octet-stream"
  @targetName("text_plain")
  val `text/plain` :  ContentType = "text/plain"
end ContentType


/** Serves as a key to response negotiation */
case class ResponseCoords(statusCode : Int, contentType : ContentType)

type Unmarshal[A] = ResponseData => Try[A]

type Marshal[A] = ContentType => A => Binary

opaque type HttpData = Map[String, _]
object HttpData {
  def apply(pears : (String, _)*): HttpData = pears.toMap
}

extension (data: HttpData) {
  def toMap: Map[String, _] = data
}
case class RequestData[A](
    path: String,
    headers: HttpData = HttpData(),
    cookies: HttpData = HttpData(),
    formData: HttpData = HttpData(),
    queryParams: HttpData = HttpData(),
    body: Option[A] = None
)

case class ResponseData(
    coords : ResponseCoords,
    headers: HttpData = HttpData(),
    cookies: HttpData = HttpData(),
    body: Option[Binary] = None)

enum HttpRequest[A]:
  case Get(content: RequestData[A])
  case Put(content: RequestData[A])
  case Post(content: RequestData[A])
  case Delete(content: RequestData[A])
  case Patch(content: RequestData[A])
  case Custom(method: String, content: RequestData[A])

  def content: RequestData[A]
  def url: String = content.path
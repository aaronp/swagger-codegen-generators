{{>licenseInfo}}

package {{modelPackage}}

// model package
import upickle.default._
import java.time.*
import java.time.format.DateTimeFormatter

given ReadWriter[ZonedDateTime] = readwriter[String].bimap[ZonedDateTime](
  zonedDateTime => DateTimeFormatter.ISO_INSTANT.format(zonedDateTime),
  str => ZonedDateTime.parse(str, DateTimeFormatter.ISO_INSTANT))

given ReadWriter[LocalDateTime] = readwriter[String].bimap[LocalDateTime](
  zonedDateTime => DateTimeFormatter.ISO_INSTANT.format(zonedDateTime),
  str => LocalDateTime.parse(str, DateTimeFormatter.ISO_INSTANT))

given ReadWriter[LocalDate] = readwriter[String].bimap[LocalDate](
  zonedDateTime => DateTimeFormatter.ISO_INSTANT.format(zonedDateTime),
  str => LocalDate.parse(str, DateTimeFormatter.ISO_INSTANT))

trait Read[-A, +R]:
    def read(input: A): R

object Read {
    def apply[A,R](f : A => R) = new Read[A,R] {
        override def read(input: A): R = f(input)
    }
    given Read[Array[Byte], String] with {
        def read(bytes: Array[Byte]) = new String(bytes)
    }

    given fromJson[A](using fromJson: upickle.default.Reader[A]): Read[Array[Byte], A] with {
        def read(bytes: Array[Byte]) = {
            val jason = ujson.read(new String(bytes))
            upickle.default.read[A](jason)
        }
    }
}
trait Write[-A, +R]:
    def write(input: A): R

object Write:

    def apply[A,R](f : A => R) = new Write[A,R] {
        override def write(input: A): R = f(input)
    }
    given Write[Object, Array[Byte]] with {
        def write(input: Object) = input match {
            case bytes : Array[Byte] => bytes
            case other => sys.error("Can't write '$other' to bytes")
        }
    }
end Write